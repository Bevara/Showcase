<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Native versus Wasm-based Video decoding</title>
    <script src="../scripts/universal-canvas_1.js"></script>
    <style>
        body {
            font-family: system-ui, sans-serif;
            line-height: 1.6;
            max-width: 900px;
            margin: 0 auto;
            padding: 2rem;
            background: #f9f9f9;
            color: #333;
        }

        h1,
        h2 {
            color: #0b3d91;
        }

        code {
            background: #eee;
            padding: 0.2em 0.4em;
            border-radius: 4px;
        }

        table {
            width: 300px;
            border-collapse: collapse;
            margin-bottom: 10px;
        }

        th,
        td {
            border: 1px solid #aaa;
            padding: 8px;
            text-align: left;
        }

        .total-row {
            border-top: 2px solid black;
            font-weight: bold;
        }
    </style>
</head>

<body>
    <a href="javascript:history.back()">&larr; Back</a>
    <h1> Native JXL vs WebAssembly Video decoding Benchmark </h1>
  
    <p>In this benchmark, we decode as fast as possible the ogg file <a
        href="http://download.blender.org/peach/trailer/trailer_1080p.ogg">trailer_1080p.ogg</a>
    
    using a native browser implementation (where supported) and a Wasm-based-JXL decoding pipeline. </p>
    
    <h2>  Native video decoding with theora </h2>
        <p>  The native section of this demonstration will work on a chrome version (Version 104.0.5112.101) which supports theora decoding natively. </p>
    <p> Framerate of the native tag <em>video</em>  is an approximative calculation of how fast the decoding can be done at playbackRate=16 (maximum value) </p>   

    <video id="video" src="../test_sequences/trailer_1080p.ogg" autoplay muted playsinline></video>
    
    <p>Native performance : </p>

    <div id="stats_native">Collecting data...</div>
    
    
    <h2>  Webassembly video decoding with theora </h2>
    <p> Framerate of the extended <em>video</em> tag with Webassembly is calculated using painting without waiting for the next vsync and outputed in the stats of the pipeline. </p>

    <canvas is="universal-canvas_1" data-url="../test_sequences/trailer_1080p.ogg" using="solver_with_sdl_1"
        with="ogg_1;vorbis_1;theora_1" vbench noloop report stats print="stats_wasm" printErr="stats_wasm">

    </canvas>

    <p>Webassembly performance (FPS is attached to V1 - vout and elapsed to global run_time ) :</p>
    <div style="background: green;" id="stats_wasm"></div>
    
    <script>
        const video = document.getElementById('video');
        const statsDiv = document.getElementById('stats_native');

        let frameCount = 0;
        let startTime = null;
        const fps_native = [];

        // For chrome and Safari
        function measureFrame(now, metadata) {
            if (!startTime) startTime = now;

            frameCount++;
            const elapsed = (now - startTime) / 1000;
            const fps = metadata.presentedFrames / elapsed;
            if (isFinite(fps)) {
                fps_native.push(fps);
            }
            statsDiv.textContent = `Frames: ${frameCount}, Elapsed: ${(1000000 * elapsed).toFixed(2)}us, Approx. FPS: ${fps.toFixed(2)}`;

            // Continue measuring if not ended

            video.requestVideoFrameCallback(measureFrame);

        }

        // For Firefox
        let startWallClock = null;
        let startVideoTime = null;
        let ended = false;

        function tick() {
            if (!startWallClock) {
                startWallClock = performance.now();
                startVideoTime = video.currentTime;
            }

            const now = performance.now();
            const videoTime = video.currentTime;

            const elapsedWallTime = (now - startWallClock) / 1000;
            const elapsedVideoTime = videoTime - startVideoTime;

            const decodeSpeed = elapsedVideoTime / elapsedWallTime;

            statsDiv.textContent = `
        Elapsed wall time: ${elapsedWallTime.toFixed(2)} s
        Elapsed video time: ${elapsedVideoTime.toFixed(2)} s
        Decode speed: ${decodeSpeed.toFixed(2)}x real-time
      `;
            if (!ended)
                requestAnimationFrame(tick);
        }

        video.addEventListener('loadeddata', () => {
            video.playbackRate = 16;
            // This is not supported by firefox
            if (video.requestVideoFrameCallback !== undefined) {
                video.requestVideoFrameCallback(measureFrame);
            } else {
                requestAnimationFrame(tick);
            }
        });

        video.addEventListener('ended', () => {
            ended = true;
            statsDiv.textContent += '\nVideo ended. Average FPS: ' + (fps_native.reduce((a, b) => a + b, 0) / fps_native.length).toFixed(2);
        });
    </script>
    
</body>

</html>